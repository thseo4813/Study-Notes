# 💬 프로그래밍 언어 선택: 어떤 언어로 코딩할까?

> **이 문서의 목표:** 프로젝트의 성격, 팀의 상황, 기술적 요구사항에 맞춰 **최적의 프로그래밍 언어**를 선택할 수 있는 안목을 기른다. 단순한 언어 비교를 넘어 언어의 **설계 철학**과 **패러다임**을 이해한다.

---

## 0. 핵심 질문으로 시작하기

1.  **컴파일 언어와 인터프리터 언어의 결정적 차이는?** → 실행 전 기계어 번역(속도/안정성) vs 실행 시 한 줄씩 해석(유연성/개발속도).
2.  **정적 타이핑(Static Typing)은 왜 필요한가?** → 컴파일 시점에 타입 오류를 잡아 대규모 프로젝트의 유지보수성과 안정성을 높이기 위해.
3.  **객체지향(OOP)과 함수형(FP) 패러다임의 차이는?** → 상태 변경과 객체 간 협력(OOP) vs 불변성과 순수 함수 조합(FP).
4.  **가비지 컬렉션(GC)은 항상 좋은가?** → 개발 편의성은 높지만, STW(Stop-The-World)로 인한 예측 불가능한 지연이 발생할 수 있음.

---

## 1. [개념 정의]: 왜 언어 선택이 중요한가? (Why)

언어는 단순한 도구가 아니라 **생각의 틀**을 제공합니다.
"망치를 들면 모든 게 못으로 보인다"는 말처럼, 선택한 언어의 특성에 따라 아키텍처와 해결 방식이 달라집니다.

### 1.1 스타트업 CTO의 고민 (Context)
*   **"빨리 만들어야 해" (Time-to-Market)**: Python, Ruby, JavaScript (생산성 위주)
*   **"트래픽이 폭발할 거야" (Performance)**: Go, Java, C++ (성능/동시성 위주)
*   **"절대 죽으면 안 돼" (Safety)**: Rust, Erlang (안정성 위주)

> [!NOTE]
> **핵심 통찰:** 완벽한 언어는 없습니다. 모든 선택은 **생산성, 성능, 안정성** 사이의 트레이드오프(Trade-off)입니다.

---

## 2. [원리/구조]: 언어를 구분하는 기준 (How)

### 2.1 컴파일 vs 인터프리터

| 구분 | 컴파일 언어 (C, Java, Go) | 인터프리터 언어 (Python, JS) |
| :--- | :--- | :--- |
| **동작 방식** | 소스 전체를 기계어로 번역 후 실행 | 한 줄씩 해석하며 실행 |
| **장점** | 실행 속도 빠름, 배포 전 오류 발견 | 개발 속도 빠름, 코드 수정 즉시 반영 |
| **단점** | 빌드 시간 필요, 플랫폼 종속적 | 실행 속도 느림, 런타임 에러 위험 |

### 2.2 타입 시스템 (Type System)

*   **정적 타이핑 (Static)**: `int a = 10;`
    *   컴파일러가 타입을 검사함. 버그를 미리 잡고 리팩토링이 쉬움. (Java, TS, C#)
*   **동적 타이핑 (Dynamic)**: `a = 10`
    *   런타임에 타입이 결정됨. 코드가 짧고 유연하지만 실행 중에 타입 에러 발생 가능. (Python, JS)

### 2.3 메모리 관리
*   **수동 관리 (Manual)**: C/C++. 빠르지만 메모리 누수 위험.
*   **가비지 컬렉션 (GC)**: Java, Python, Go. 편하지만 성능 오버헤드 존재.
*   **소유권 (Ownership)**: Rust. GC 없이 컴파일 타임에 메모리 안전성 보장 (학습 곡선 높음).

---

## 3. [실전/구현]: 상황별 언어 추천 가이드 (What)

### 3.1 분야별 표준 선택

1.  **웹 백엔드 (서버)**
    *   **Java/Spring**: 엔터프라이즈 표준. 안정적이고 생태계 거대함.
    *   **Node.js**: I/O가 많은 실시간 서비스, 풀스택 개발.
    *   **Go**: 마이크로서비스, 높은 동시성 처리 성능 필요 시.
    *   **Python/Django/FastAPI**: 빠른 개발, 데이터/AI 라이브러리 연동 시.

2.  **프론트엔드**
    *   **JavaScript/TypeScript**: 사실상 유일한 대안. (TypeScript가 표준이 되는 추세)

3.  **시스템/게임/임베디드**
    *   **C/C++**: 극한의 성능과 하드웨어 제어.
    *   **Rust**: C++의 성능 + 메모리 안전성.

4.  **데이터/AI**
    *   **Python**: 압도적인 라이브러리(Pandas, PyTorch) 지원.

### 3.2 코드 예시: 같은 로직, 다른 느낌

**Python (생산성)**
```python
# 매우 직관적이고 짧음
def greet(names):
    return [f"Hello, {name}!" for name in names]
```

**Java (명시성/안정성)**
```java
// 타입 명시, 구조적
public List<String> greet(List<String> names) {
    return names.stream()
        .map(name -> "Hello, " + name + "!")
        .collect(Collectors.toList());
}
```

> [!WARNING]
> **흔한 실수:** 유행하는 언어를 무작정 도입하는 것. 팀원이 익숙하고 레거시와 호환되는 언어가 1순위입니다.

---

## 4. 🎯 1분 요약

1.  **목적 적합성**: 웹은 JS/Java, 데이터는 Python, 시스템은 C/Rust/Go.
2.  **트레이드오프**: 개발 속도(Python/JS) vs 실행 성능(C/Go/Rust).
3.  **타입의 중요성**: 규모가 커질수록 **정적 타이핑(TypeScript, Java, Go)**이 유지보수에 유리하다.
4.  **팀 역량**: 가장 좋은 언어는 "우리 팀이 가장 잘 쓰는 언어"이다.

---

## 5. 📝 자가 점검 질문

1.  **스타트업 초기 MVP 개발에 Python이나 Node.js가 선호되는 이유는?**
    → 동적 타이핑과 풍부한 라이브러리로 개발 속도가 빠르고 변경에 유연하기 때문.
2.  **Java가 대규모 엔터프라이즈 시스템에서 여전히 강세인 이유는?**
    → 강력한 정적 타입 시스템, 거대한 생태계, JVM의 안정성, 인력 수급의 용이성.
3.  **Go 언어가 마이크로서비스 아키텍처에서 인기 있는 이유는?**
    → 가벼운 고루틴(Goroutine)을 통한 효율적인 동시성 처리와 빠른 빌드/배포 속도.
4.  **Rust가 C++의 대체재로 주목받는 핵심 이유는?**
    → C++ 수준의 성능을 내면서도, **메모리 안전성(Memory Safety)**을 컴파일 시점에 보장하여 치명적인 버그를 막기 때문.
