# ğŸ’» ì»´í“¨í„° ì•„í‚¤í…ì²˜: ì™œ ë‚´ ì½”ë“œê°€ ëŠë¦´ê¹Œ?

## ğŸš€ ì‹¤ì œë¡œ ê²ªì–´ë³¸ ì„±ëŠ¥ ë¬¸ì œë“¤

### ê°œë°œìë“¤ì´ í”íˆ í•˜ëŠ” ê³ ë¯¼:

**"ì™œ ë‚´ ì„œë²„ê°€ ëŠë¦´ê¹Œ?"**
- CPU ì‚¬ìš©ë¥  10%ì¸ë° ì™œ ì‘ë‹µì´ ëŠë¦¬ì§€?
- ë©”ëª¨ë¦¬ 32GB ì“°ëŠ”ë° ì™œ OutOfMemory ë‚ ê¹Œ?
- ë””ìŠ¤í¬ I/Oê°€ ë³‘ëª©ì¸ë° ì™œ SSD ì¼ëŠ”ë°ë„ ëŠë¦¬ì§€?

**"ìºì‹œê°€ ë­ê¸¸ë˜ ì¤‘ìš”í•œê°€?"**
- ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ê°€ ëŠë¦°ë° ì¸ë±ìŠ¤ë§Œ ë§Œë“¤ë©´ ë ê¹Œ?
- Redisë¥¼ ì¼ëŠ”ë° ì™œ ì—¬ì „íˆ ëŠë¦¬ì§€?
- CPU ìºì‹œ ë¯¸ìŠ¤ê°€ ì™œ ì„±ëŠ¥ì— ì´ë ‡ê²Œ í° ì˜í–¥?

**"ë³‘ë ¬ì²˜ë¦¬ê°€ ì™œ ì•ˆ ë˜ì§€?"**
- 8ì½”ì–´ CPUì¸ë° ì™œ ì‹±ê¸€ì½”ì–´ë§Œ ì“°ëŠ” ê²ƒ ê°™ì§€?
- ë©€í‹°ìŠ¤ë ˆë”© ì½”ë“œ ì§°ëŠ”ë° ì„±ëŠ¥ì´ ì•ˆ ì˜¤ë¥´ë„¤?
- GPU ì»´í“¨íŒ…ì´ ì™œ ê²Œì„ì—ì„œë§Œ ì¤‘ìš”í•˜ì§€?

## ğŸ¯ 1ë¶„ ìš”ì•½: ì™œ ì»´í“¨í„° ì•„í‚¤í…ì²˜ë¥¼ ì•Œì•„ì•¼ í•˜ë‚˜?

**í•˜ë“œì›¨ì–´ = ì†Œí”„íŠ¸ì›¨ì–´ì˜ í•œê³„**

- **CPU**: ì—°ì‚°ì˜ ì†ë„ ì œí•œ
- **ë©”ëª¨ë¦¬**: ë°ì´í„° ì ‘ê·¼ì˜ ë³‘ëª©
- **ìºì‹œ**: ì„±ëŠ¥ì˜ 90% ê²°ì •
- **I/O**: ì™¸ë¶€ ì¥ì¹˜ì™€ì˜ ì†ë„ ì°¨ì´

> **ê²°ë¡ :**
> 1. **ìºì‹œ ìµœì í™”**: ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´ì´ ì„±ëŠ¥ ì¢Œìš°
> 2. **ë³‘ë ¬ ì²˜ë¦¬**: CPU ì½”ì–´ ìˆ˜ì— ë§ê²Œ ì„¤ê³„
> 3. **I/O ìµœì í™”**: ë””ìŠ¤í¬ì™€ ë„¤íŠ¸ì›Œí¬ ë³‘ëª© í•´ê²°
> 4. **ë©”ëª¨ë¦¬ ê³„ì¸µ**: ê° ë ˆë²¨ì˜ íŠ¹ì§• ì´í•´

---

## 1. ğŸ§­ ë¹ ë¥¸ ë³‘ëª© ì§€ë„ (ì¦ìƒ â†’ ì•„í‚¤í…ì²˜ ê´€ì )

ì•„ë˜ëŠ” ì‹¤ë¬´ì—ì„œ ìì£¼ ê²ªëŠ” â€œëŠë¦¼â€ì„ **ì•„í‚¤í…ì²˜ ê´€ì ìœ¼ë¡œ ë²ˆì—­**í•œ ê²ƒì…ë‹ˆë‹¤.

| ì¦ìƒ(ê´€ì°°) | ì•„í‚¤í…ì²˜ ê´€ì ì—ì„œì˜ í›„ë³´ ì›ì¸ | ë‹¤ìŒì— ë³¼ ê²ƒ |
|---|---|---|
| CPU ì‚¬ìš©ë¥ ì´ ë‚®ì€ë° ì‘ë‹µì´ ëŠë¦¼ | I/O ëŒ€ê¸°, ë½ ê²½í•©, ë„¤íŠ¸ì›Œí¬ ëŒ€ê¸°, ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ | I/O ì§€í‘œ, ìŠ¤ë ˆë“œ ë¤í”„, í ê¸¸ì´ |
| CPU ì‚¬ìš©ë¥ ì€ ë†’ì€ë° ì²˜ë¦¬ëŸ‰ì´ ì•ˆ ë‚˜ì˜´ | ìºì‹œ ë¯¸ìŠ¤, ë¶„ê¸° ì˜ˆì¸¡ ì‹¤íŒ¨, ë©”ëª¨ë¦¬ ëŒ€ì—­í­ ë³‘ëª© | ìºì‹œ ë¯¸ìŠ¤ìœ¨, IPC, branch-misses |
| â€œë£¨í”„/ë°°ì—´ ì²˜ë¦¬â€ê°€ ìœ ë‚œíˆ ëŠë¦¼ | ì ‘ê·¼ íŒ¨í„´ì´ ì§€ì—­ì„±ì— ë¶ˆë¦¬, false sharing | ìˆœì°¨ ì ‘ê·¼/ë¸”ë¡œí‚¹, ìºì‹œ ë¼ì¸ ì •ë ¬ |
| ë©€í‹°ì½”ì–´ì¸ë° ìŠ¤ì¼€ì¼ì´ ì•ˆ ë¨ | ê³µìœ  ìƒíƒœ/ë½, false sharing, NUMA, ë³‘ë ¬í™” ì˜¤ë²„í—¤ë“œ | ë½ í”„ë¡œíŒŒì¼ë§, NUMA ë°°ì¹˜ |

> í•µì‹¬ì€ â€œCPUê°€ ë°”ë¹ ì„œ ëŠë¦°ì§€â€ê°€ ì•„ë‹ˆë¼, **CPUê°€ ë¬´ì—‡ì„ ê¸°ë‹¤ë¦¬ëŠ”ì§€**ë¥¼ êµ¬ë¶„í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

---

## 2. ğŸ“š ì»´í“¨í„°ê°€ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•˜ëŠ” ì›ë¦¬

### 2.1 ì™œ ì»´í“¨í„°ëŠ” ì´ë ‡ê²Œ ì„¤ê³„ë˜ì—ˆì„ê¹Œ?

**í° ë…¸ì´ë§Œ ì•„í‚¤í…ì²˜ = ì»´í“¨í„°ì˜ ê¸°ë³¸ ì„¤ê³„ë„**

**ğŸ’¡ í•µì‹¬ ê°œë…:**
- **ì €ì¥ í”„ë¡œê·¸ë¨**: í”„ë¡œê·¸ë¨ì„ ë©”ëª¨ë¦¬ì— ì €ì¥í•´ë‘ê³  í•˜ë‚˜ì”© ì‹¤í–‰
- **ê³µí†µ ë²„ìŠ¤**: CPU â†” ë©”ëª¨ë¦¬ â†” ë””ìŠ¤í¬ ëª¨ë‘ ê°™ì€ ê¸¸ë¡œ ì—°ê²°

**ì‹¤ì œ ì˜í–¥:**
- **ë©”ëª¨ë¦¬ì™€ í”„ë¡œê·¸ë¨ì´ ê°™ì€ ë²„ìŠ¤ ì‚¬ìš©** â†’ ë©”ëª¨ë¦¬ ì ‘ê·¼ì´ CPU ì„±ëŠ¥ì˜ ë³‘ëª©
- **ìˆœì°¨ì  ì‹¤í–‰** â†’ ë³‘ë ¬ ì²˜ë¦¬ê°€ ì–´ë ¤ì›€
- **ë²”ìš©ì„±** â†’ ì–´ë–¤ í”„ë¡œê·¸ë¨ì´ë“  ì‹¤í–‰ ê°€ëŠ¥

```mermaid
graph TD
    subgraph CPU [Central Processing Unit CPU]
        CU[Control Unit<br/>ì œì–´ ì¥ì¹˜]
        ALU[ALU<br/>ì‚°ìˆ  ë…¼ë¦¬ ì¥ì¹˜]
        Reg[Registers<br/>ë ˆì§€ìŠ¤í„°]
        
        CU --- ALU
        CU --- Reg
        ALU --- Reg
    end

    Bus{System Bus<br/>ì‹œìŠ¤í…œ ë²„ìŠ¤}

    Memory[Memory<br/>ì£¼ê¸°ì–µì¥ì¹˜]
    IO[I/O Devices<br/>ì…ì¶œë ¥ ì¥ì¹˜]

    CPU <==> Bus
    Bus <==> Memory
    Bus <==> IO

    style CPU fill:#e3f2fd,stroke:#1565c0
    style Memory fill:#fff3e0,stroke:#ef6c00
    style IO fill:#f3e5f5,stroke:#7b1fa2
    style Bus fill:#eeeeee,stroke:#333333
```

### 2.2 í•˜ë²„ë“œ ì•„í‚¤í…ì²˜ (Harvard Architecture)

**íŠ¹ì§•:**
- ëª…ë ¹ì–´ì™€ ë°ì´í„°ë¥¼ ë¶„ë¦¬ëœ ë©”ëª¨ë¦¬ì— ì €ì¥
- DSP, GPU ë“± íŠ¹ìˆ˜ ëª©ì  í”„ë¡œì„¸ì„œì—ì„œ ì‚¬ìš©
- ëª…ë ¹ì–´ì™€ ë°ì´í„° ë²„ìŠ¤ê°€ ë¶„ë¦¬ë˜ì–´ ë™ì‹œ ì ‘ê·¼ ê°€ëŠ¥

---

## 3. CPU ì•„í‚¤í…ì²˜ì™€ ëª…ë ¹ì–´ ì²˜ë¦¬

### 3.1 CPUì˜ êµ¬ì„± ìš”ì†Œ

#### 3.1.1 ì‚°ìˆ  ë…¼ë¦¬ ì¥ì¹˜ (ALU - Arithmetic Logic Unit)
```python
class ALU:
    def execute(self, operation, operand1, operand2):
        # Conceptual ALU operations (not CPU-accurate).
        op = operation.upper()

        if op == "ADD":
            return operand1 + operand2
        if op == "SUB":
            return operand1 - operand2
        if op == "MUL":
            return operand1 * operand2
        if op == "DIV":
            if operand2 == 0:
                raise ZeroDivisionError("DIV by zero")
            return operand1 // operand2

        if op == "AND":
            return operand1 & operand2
        if op == "OR":
            return operand1 | operand2
        if op == "XOR":
            return operand1 ^ operand2

        if op == "SHL":
            return operand1 << operand2
        if op == "SHR":
            return operand1 >> operand2

        raise ValueError(f"Unsupported operation: {operation}")
```

#### 3.1.2 ì œì–´ ì¥ì¹˜ (Control Unit)
- **ëª…ë ¹ì–´ í•´ì„:** ê¸°ê³„ì–´ë¥¼ í•´ì„í•˜ì—¬ ì œì–´ ì‹ í˜¸ ìƒì„±
- **í”„ë¡œê·¸ë¨ ì¹´ìš´í„°:** ë‹¤ìŒ ì‹¤í–‰í•  ëª…ë ¹ì–´ ì£¼ì†Œ ê´€ë¦¬
- **ëª…ë ¹ì–´ ë ˆì§€ìŠ¤í„°:** í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ëª…ë ¹ì–´ ì €ì¥

#### 3.1.3 ë ˆì§€ìŠ¤í„° (Registers)
**ë²”ìš© ë ˆì§€ìŠ¤í„°:**
- **AX, BX, CX, DX** (x86 ì•„í‚¤í…ì²˜)
- ë°ì´í„° ì„ì‹œ ì €ì¥ê³¼ ì—°ì‚°ì— ì‚¬ìš©

**íŠ¹ìˆ˜ ëª©ì  ë ˆì§€ìŠ¤í„°:**
- **PC (Program Counter):** ë‹¤ìŒ ëª…ë ¹ì–´ ì£¼ì†Œ
- **SP (Stack Pointer):** ìŠ¤íƒ ìµœìƒë‹¨ ì£¼ì†Œ
- **IR (Instruction Register):** í˜„ì¬ ëª…ë ¹ì–´ ì €ì¥

### 3.2 ëª…ë ¹ì–´ ì§‘í•© ì•„í‚¤í…ì²˜ (ISA)

#### 3.2.1 CISC vs RISC

| ì¸¡ë©´ | CISC (Complex Instruction Set Computer) | RISC (Reduced Instruction Set Computer) |
| --- | --- | --- | --- |
| **ëª…ë ¹ì–´ ìˆ˜** | ë§ìŒ (200-300ê°œ) | ì ìŒ (ì•½ 100ê°œ) |
| **ëª…ë ¹ì–´ ê¸¸ì´** | ê°€ë³€ ê¸¸ì´ | ê³ ì • ê¸¸ì´ |
| **í´ëŸ­ ì‚¬ì´í´** | ê°€ë³€ (1-20 ì‚¬ì´í´) | ê³ ì • (1-2 ì‚¬ì´í´) |
| **ë©”ëª¨ë¦¬ ì ‘ê·¼** | ë³µì¡í•œ ëª¨ë“œ | ë‹¨ìˆœí•œ ëª¨ë“œ |
| **ì˜ˆì‹œ** | x86 (Intel, AMD) | ARM, MIPS, RISC-V |

**RISCì˜ ì¥ì :**
```mermaid
gantt
    title RISC Pipeline Efficiency
    dateFormat  s
    axisFormat %s
    
    section Pipeline
    LOAD (Mem->R1)  :done, a1, 0, 1s
    ADD (R1+R4->R3) :done, a2, after a1, 1s
    STORE (R3->Mem) :done, a3, after a2, 1s
```

### 3.3 ëª…ë ¹ì–´ ì‹¤í–‰ ì‚¬ì´í´

#### 3.3.1 ê¸°ë³¸ ëª…ë ¹ì–´ ì‚¬ì´í´
```
1. Fetch: ë©”ëª¨ë¦¬ì—ì„œ ëª…ë ¹ì–´ ê°€ì ¸ì˜¤ê¸°
2. Decode: ëª…ë ¹ì–´ í•´ì„
3. Execute: ëª…ë ¹ì–´ ì‹¤í–‰
4. Memory: ë©”ëª¨ë¦¬ ì ‘ê·¼ (í•„ìš”ì‹œ)
5. Write-back: ê²°ê³¼ ì €ì¥
```

#### 3.3.2 íŒŒì´í”„ë¼ì´ë‹ (Pipelining)

**ë³‘ë ¬ ì²˜ë¦¬ ê¸°ë²•:**
```mermaid
gantt
    title 5-Stage Pipeline Execution
    dateFormat  s
    axisFormat %s

    section Instruction 1
    Fetch       :a1, 0, 1s
    Decode      :a2, after a1, 1s
    Execute     :a3, after a2, 1s
    Memory      :a4, after a3, 1s
    Write-back  :a5, after a4, 1s

    section Instruction 2
    Fetch       :b1, after a1, 1s
    Decode      :b2, after b1, 1s
    Execute     :b3, after b2, 1s
    Memory      :b4, after b3, 1s
    Write-back  :b5, after b4, 1s

    section Instruction 3
    Fetch       :c1, after b1, 1s
    Decode      :c2, after c1, 1s
    Execute     :c3, after c2, 1s
    Memory      :c4, after c3, 1s
    Write-back  :c5, after c4, 1s
```

**íŒŒì´í”„ë¼ì¸ í•´ì €ë“œ (Hazards):**
- **ë°ì´í„° í•´ì €ë“œ:** ëª…ë ¹ì–´ ê°„ ë°ì´í„° ì˜ì¡´ì„±
- **ì œì–´ í•´ì €ë“œ:** ë¶„ê¸° ëª…ë ¹ì–´ë¡œ ì¸í•œ íŒŒì´í”„ë¼ì¸ í”ŒëŸ¬ì‹œ
- **êµ¬ì¡°ì  í•´ì €ë“œ:** í•˜ë“œì›¨ì–´ ìì› ì¶©ëŒ

---

## 4. ğŸ§  ë©”ëª¨ë¦¬ ê³„ì¸µ: ì™œ ë¹ ë¥¸ ë©”ëª¨ë¦¬ê°€ ì¤‘ìš”í• ê¹Œ?

### 4.1 ë©”ëª¨ë¦¬ ì†ë„ ì°¨ì´ê°€ ì‹¤ì œ ì„±ëŠ¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥

**ğŸš¨ ì¶©ê²©ì ì¸ ì‚¬ì‹¤:**
- **CPU ë ˆì§€ìŠ¤í„°**: 1ë‚˜ë…¸ì´ˆ (1ns)
- **ë©”ì¸ ë©”ëª¨ë¦¬**: 100ë‚˜ë…¸ì´ˆ (100ns) â†’ **100ë°° ëŠë¦¼!**
- **SSD**: 100ë§ˆì´í¬ë¡œì´ˆ (100Î¼s) â†’ **10ë§Œë°° ëŠë¦¼!**
- **HDD**: 10ë°€ë¦¬ì´ˆ (10ms) â†’ **1ì²œë§Œë°° ëŠë¦¼!**

**ğŸ’¡ ì‹¤ì œ ì˜í–¥:**
```java
// ìºì‹œ íˆíŠ¸: 1ns
int fast = registerValue;

// ìºì‹œ ë¯¸ìŠ¤: 100ns (100ë°° ëŠë¦¼!)
int slow = mainMemory[1000000];

// ë””ìŠ¤í¬ ì ‘ê·¼: 10ms (1ì²œë§Œë°° ëŠë¦¼!)
int verySlow = loadFromDisk();
```

**ê°œë°œì ê´€ì :**
- **ìºì‹œ íˆíŠ¸ìœ¨ 99%**: ì´ˆê³ ì†
- **ìºì‹œ íˆíŠ¸ìœ¨ 90%**: 10ë°° ëŠë¦¼
- **ìºì‹œ íˆíŠ¸ìœ¨ 50%**: 100ë°° ëŠë¦¼

### 4.2 ìºì‹œ ìµœì í™”: ì½”ë“œ ì„±ëŠ¥ì˜ 90%

#### 4.2.1 ì§€ì—­ì„±ì˜ ì›ì¹™ (ì‹¤ì œ ì½”ë“œë¡œ ì´í•´í•˜ê¸°)

**ì‹œê°„ ì§€ì—­ì„±: "ë°©ê¸ˆ ì“´ ë°ì´í„°ëŠ” ë‹¤ì‹œ ì“¸ ê°€ëŠ¥ì„±ì´ ë†’ë‹¤"**
```java
// ì¢‹ì€ ì˜ˆ: ê°™ì€ ë°ì´í„° ë°˜ë³µ ì‚¬ìš©
int sum = 0;
for (int i = 0; i < 1000000; i++) {
    sum += array[i];  // sumì€ ìºì‹œì— ê³„ì† ë‚¨ì•„ìˆìŒ
}
```

**ê³µê°„ ì§€ì—­ì„±: "ì˜†ì— ìˆëŠ” ë°ì´í„°ë„ ê³§ ì“¸ ê°€ëŠ¥ì„±ì´ ë†’ë‹¤"**
```java
// ì¢‹ì€ ì˜ˆ: ìˆœì°¨ì  ì ‘ê·¼
for (int i = 0; i < 1000; i++) {
    sum += array[i];  // ë‹¤ìŒ array[i+1]ì€ ì´ë¯¸ ìºì‹œì— ë¡œë“œë¨
}

// ë‚˜ìœ ì˜ˆ: ëœë¤ ì ‘ê·¼ (ìºì‹œ ë¯¸ìŠ¤!)
for (int i = 0; i < 1000; i++) {
    int randomIndex = (int)(Math.random() * 1000000);
    sum += array[randomIndex];  // ìºì‹œ ë¯¸ìŠ¤ ë¹ˆë²ˆ!
}
```

#### 4.2.2 ìºì‹œ ë§¤í•‘ ë°©ì‹

**ì§ì ‘ ë§¤í•‘ (Direct Mapping):**
```
ë©”ëª¨ë¦¬ ì£¼ì†Œ â†’ ìºì‹œ ì¸ë±ìŠ¤ ê³„ì‚°
ìºì‹œ ë¼ì¸ ìˆ˜ = 2^k ì´ë©´, ì£¼ì†Œ % 2^k = ìºì‹œ ì¸ë±ìŠ¤
```

**ì—°ê´€ ë§¤í•‘ (Associative Mapping):**
```
ë©”ëª¨ë¦¬ ì£¼ì†Œ â†’ íƒœê·¸ ë¹„êµë¡œ ìºì‹œ ê²€ìƒ‰
ëª¨ë“  ìºì‹œ ë¼ì¸ì— ëŒ€í•´ íƒœê·¸ ë¹„êµ (ëŠë¦¬ì§€ë§Œ ìœ ì—°)
```

**ì„¸íŠ¸ ì—°ê´€ ë§¤í•‘ (Set-Associative Mapping):**
```
ì§ì ‘ ë§¤í•‘ + ì—°ê´€ ë§¤í•‘ì˜ í•˜ì´ë¸Œë¦¬ë“œ
ê° ì„¸íŠ¸ ë‚´ì—ì„œ ì—°ê´€ ê²€ìƒ‰
```

### 4.3 ìºì‹œ ì¼ê´€ì„± (Cache Coherence)

**ë©€í‹°ì½”ì–´ ì‹œìŠ¤í…œì—ì„œì˜ ë¬¸ì œ:**
```mermaid
sequenceDiagram
    participant CPU1 as CPU 1
    participant CPU2 as CPU 2
    participant RAM as Memory (RAM)

    Note over CPU1, CPU2: Initial State: X = 10 in RAM

    CPU1->>RAM: 1. Load X
    RAM-->>CPU1: X = 10
    Note left of CPU1: Cache: X=10

    CPU2->>RAM: 2. Load X
    RAM-->>CPU2: X = 10
    Note right of CPU2: Cache: X=10

    Note left of CPU1: 3. Update X = 20
    CPU1->>CPU1: X = 20 (Dirty)
    
    CPU2->>CPU2: 4. Read X
    Note right of CPU2: Still X=10! (Stale Data)
    
    Note over CPU1, CPU2: âŒ Inconsistency Problem!
```

**í•´ê²°ì±…:**
- **MESI í”„ë¡œí† ì½œ:** Modified, Exclusive, Shared, Invalid ìƒíƒœ
- **ìŠ¤ëˆ„í•‘:** ë‹¤ë¥¸ ìºì‹œì˜ ë³€ê²½ì‚¬í•­ ëª¨ë‹ˆí„°ë§

---

## 5. ë³‘ë ¬ ì²˜ë¦¬ ì•„í‚¤í…ì²˜

### 5.1 Flynnì˜ ë¶„ë¥˜

#### 5.1.1 SISD (Single Instruction, Single Data)
- ë‹¨ì¼ ëª…ë ¹ì–´ê°€ ë‹¨ì¼ ë°ì´í„°ì— ì ìš©
- ì „í†µì ì¸ ìˆœì°¨ ì»´í“¨í„°

#### 5.1.2 SIMD (Single Instruction, Multiple Data)
- ë‹¨ì¼ ëª…ë ¹ì–´ê°€ ë‹¤ìˆ˜ì˜ ë°ì´í„°ì— ì ìš©
- ë²¡í„° í”„ë¡œì„¸ì„œ, GPU

```c
// SIMD ì˜ˆì‹œ (Intel AVX)
#include <immintrin.h>

void vector_add(float *a, float *b, float *result, int n) {
    for (int i = 0; i < n; i += 8) {
        __m256 va = _mm256_load_ps(&a[i]);
        __m256 vb = _mm256_load_ps(&b[i]);
        __m256 vc = _mm256_add_ps(va, vb);
        _mm256_store_ps(&result[i], vc);
    }
}
```

#### 5.1.3 MISD (Multiple Instruction, Single Data)
- ì—¬ëŸ¬ ëª…ë ¹ì–´ê°€ ë‹¨ì¼ ë°ì´í„°ì— ì ìš©
- ì´ë¡ ì ìœ¼ë¡œëŠ” ì¡´ì¬í•˜ì§€ë§Œ ì‹¤ì œë¡œëŠ” ë“œë¬¾

#### 5.1.4 MIMD (Multiple Instruction, Multiple Data)
- ì—¬ëŸ¬ ëª…ë ¹ì–´ê°€ ì—¬ëŸ¬ ë°ì´í„°ì— ì ìš©
- ë©€í‹°ì½”ì–´ CPU, í´ëŸ¬ìŠ¤í„° ì»´í“¨í„°

### 5.2 í˜„ëŒ€ í”„ë¡œì„¸ì„œì˜ ë³‘ë ¬í™” ê¸°ë²•

#### 5.2.1 ìŠˆí¼ìŠ¤ì¹¼ë¼ (Superscalar)
- í•œ í´ëŸ­ì— ì—¬ëŸ¬ ëª…ë ¹ì–´ ì‹¤í–‰
- ì¸í…” Pentiumë¶€í„° ë„ì…

#### 5.2.2 ì•„ì›ƒ-ì˜¤ë¸Œ-ì˜¤ë” ì‹¤í–‰ (Out-of-Order Execution)
```mermaid
graph TD
    subgraph Original [Original Sequence (Stall ë°œìƒ)]
        O1[1. LOAD R1, addr]
        O2[2. ADD R2, R3, R4]
        O3[3. MUL R5, R6, R7]
        
        O1 -- "Waiting Memory..." --> O2
        O2 -- "Blocked by 1?" --> O3
    end

    subgraph Reordered [Reordered (íš¨ìœ¨ì )]
        R2[2. ADD R2, R3, R4]
        R3[3. MUL R5, R6, R7]
        R1[1. LOAD R1, addr]
        
        R2 -- "Execute Immediately" --> R3
        R3 -- "Execute Immediately" --> R1
        R1 -- "Complete later" --> Done((Done))
    end

    style Original fill:#ffebee,stroke:#c62828
    style Reordered fill:#e8f5e9,stroke:#2e7d32
```

#### 5.2.3 ë¶„ê¸° ì˜ˆì¸¡ (Branch Prediction)
**ë¶„ê¸° ëª…ë ¹ì–´ì˜ ì„±ëŠ¥ ì˜í–¥:**
```text
[ë¶„ê¸° ì˜ˆì¸¡ì˜ ì¤‘ìš”ì„±]

if (condition) {     // ë¶„ê¸° ëª…ë ¹ì–´
    do_something();
} else {
    do_other();
}

ì‹¤í–‰: ì¡°ê±´ í‰ê°€ â†’ ì˜ˆì¸¡ â†’ ì‹¤í–‰ â†’ ê²€ì¦ â†’ ìˆ˜ì • (í•„ìš”ì‹œ)
```

**ë¶„ê¸° ì˜ˆì¸¡ ê¸°ë²•:**
- **ì •ì  ì˜ˆì¸¡:** í•­ìƒ taken ë˜ëŠ” not taken ê°€ì •
- **ë™ì  ì˜ˆì¸¡:** ê³¼ê±° íŒ¨í„´ ê¸°ë°˜ ì˜ˆì¸¡ (2ë¹„íŠ¸ ì¹´ìš´í„°)

---

## 6. I/O ì‹œìŠ¤í…œê³¼ ì¸í„°ëŸ½íŠ¸

### 6.1 I/O ì¥ì¹˜ì™€ CPUì˜ ì—°ê²°

#### 6.1.1 í´ë§ (Polling)
```c
// í´ë§ ë°©ì‹ I/O
while (1) {
    if (keyboard_has_data()) {
        char c = read_keyboard();
        process_character(c);
    }
    // ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰
}
```
**ë‹¨ì :** CPU ë‚­ë¹„, ì‹¤ì‹œê°„ì„± ë¶€ì¡±

#### 6.1.2 ì¸í„°ëŸ½íŠ¸ (Interrupt)
```c
// ì¸í„°ëŸ½íŠ¸ ë°©ì‹ I/O (ê°œë…ì )
void keyboard_interrupt_handler() {
    char c = read_keyboard();
    process_character(c);
    // ì¸í„°ëŸ½íŠ¸ ì„œë¹„ìŠ¤ ë£¨í‹´ (ISR) ì‹¤í–‰
}

// ë©”ì¸ í”„ë¡œê·¸ë¨
void main() {
    setup_interrupt_handler(KEYBOARD_IRQ, keyboard_interrupt_handler);
    enable_interrupts();

    while (1) {
        do_useful_work();  // CPUê°€ ë‹¤ë¥¸ ì‘ì—…ì— ì§‘ì¤‘
    }
}
```

### 6.2 DMA (Direct Memory Access)

**CPU ê°œì… ì—†ì´ ë©”ëª¨ë¦¬ â†” I/O ì¥ì¹˜ ê°„ ì§ì ‘ ì „ì†¡:**
```mermaid
sequenceDiagram
    participant CPU
    participant DMA as DMA Controller
    participant IO as I/O Device
    participant Mem as Memory

    CPU->>DMA: 1. ëª…ë ¹ ì„¤ì • (ì£¼ì†Œ, í¬ê¸°, ì œì–´)
    activate DMA
    Note right of CPU: CPUëŠ” ë‹¤ë¥¸ ì‘ì—… ìˆ˜í–‰ ê°€ëŠ¥
    
    DMA->>IO: 2. ë°ì´í„° ìš”ì²­
    IO->>Mem: ì§ì ‘ ì „ì†¡ (CPU bypass)
    Mem-->>IO: Ack
    IO-->>DMA: ì „ì†¡ ì™„ë£Œ
    
    DMA->>CPU: 3. ì™„ë£Œ ì¸í„°ëŸ½íŠ¸ (Interrupt)
    deactivate DMA
```

**ì¥ì :**
- CPU ë¶€í•˜ ê°ì†Œ
- ê³ ì† I/O ê°€ëŠ¥
- ë³‘ë ¬ ì²˜ë¦¬ ì§€ì›

---

## 7. í˜„ëŒ€ ì»´í“¨í„° ì•„í‚¤í…ì²˜ì˜ íŠ¸ë Œë“œ

### 7.1 ë©€í‹°ì½”ì–´ì™€ í•˜ì´í¼ìŠ¤ë ˆë”©

**í•˜ì´í¼ìŠ¤ë ˆë”© (Hyper-Threading):**
- í•˜ë‚˜ì˜ ë¬¼ë¦¬ ì½”ì–´ë¥¼ ë‘ ê°œì˜ ë…¼ë¦¬ ì½”ì–´ë¡œ í‘œí˜„
- ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ë¹„ìš© ì—†ì´ ë³‘ë ¬ ì‹¤í–‰

### 7.2 ë©”ëª¨ë¦¬ ê¸°ìˆ  ë°œì „

#### 7.2.1 3D ìŠ¤íƒœí‚¹ ë©”ëª¨ë¦¬ (3D Stacked Memory)
- ë©”ëª¨ë¦¬ ì¹©ì„ ìˆ˜ì§ìœ¼ë¡œ ìŒ“ì•„ ëŒ€ì—­í­ ì¦ê°€
- HBM (High Bandwidth Memory) ê¸°ìˆ 

#### 7.2.2 ì¸í…” ì˜µí…Œì¸ (Intel Optane)
- DRAMê³¼ NANDì˜ ì¤‘ê°„ ì„±ëŠ¥
- ë¹„íœ˜ë°œì„± ë©”ëª¨ë¦¬ë¡œ ì‹œìŠ¤í…œ ì¬ì‹œì‘ ì‹œ ë°ì´í„° ìœ ì§€

### 7.3 íŠ¹ìˆ˜ ëª©ì  í”„ë¡œì„¸ì„œ

#### 7.3.1 GPU (Graphics Processing Unit)
- ìˆ˜ì²œ ê°œì˜ ì½”ì–´ë¡œ ë³‘ë ¬ ì—°ì‚° íŠ¹í™”
- CUDA, OpenCL í”„ë ˆì„ì›Œí¬ë¡œ í”„ë¡œê·¸ë˜ë°

#### 7.3.2 TPU (Tensor Processing Unit)
- ë”¥ëŸ¬ë‹ ì—°ì‚° ìµœì í™”
- êµ¬ê¸€ì˜ ë¨¸ì‹ ëŸ¬ë‹ ê°€ì†ê¸°

#### 7.3.3 FPGA (Field Programmable Gate Array)
- í”„ë¡œê·¸ë˜ë° ê°€ëŠ¥í•œ í•˜ë“œì›¨ì–´
- ASICë³´ë‹¤ ìœ ì—°í•˜ë©´ì„œ GPUë³´ë‹¤ íš¨ìœ¨ì 

---

## 8. ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œìë¥¼ ìœ„í•œ ì•„í‚¤í…ì²˜ ì´í•´

### 8.1 ë©”ëª¨ë¦¬ ì •ë ¬ê³¼ ìºì‹œ ë¼ì¸

**ìºì‹œ ë¼ì¸ í¬ê¸° ê³ ë ¤:**
```c
// ë¹„íš¨ìœ¨ì ì¸ ë©”ëª¨ë¦¬ ì ‘ê·¼
struct Data {
    char a;    // 1ë°”ì´íŠ¸
    int b;     // 4ë°”ì´íŠ¸ â†’ íŒ¨ë”©ìœ¼ë¡œ 3ë°”ì´íŠ¸ ë‚­ë¹„
    char c;    // 1ë°”ì´íŠ¸
}; // ì´ 12ë°”ì´íŠ¸ (íŒ¨ë”© í¬í•¨)

// íš¨ìœ¨ì ì¸ ë°°ì¹˜
struct OptimizedData {
    int b;     // 4ë°”ì´íŠ¸
    char a;    // 1ë°”ì´íŠ¸
    char c;    // 1ë°”ì´íŠ¸
    char padding[2]; // ëª…ì‹œì  íŒ¨ë”©
}; // ì´ 8ë°”ì´íŠ¸
```

### 8.2 ë¶„ê¸° ì˜ˆì¸¡ ìµœì í™”

**ì¡°ê±´ë¬¸ ìµœì í™”:**
```c
// ë¶„ê¸° ì˜ˆì¸¡ì— ë¶ˆë¦¬í•œ íŒ¨í„´
if (rare_condition) {  // ê±°ì˜ ë°œìƒí•˜ì§€ ì•ŠëŠ” ì¡°ê±´
    handle_rare_case(); // CPU ì˜ˆì¸¡ ì‹¤íŒ¨ë¡œ íŒŒì´í”„ë¼ì¸ í”ŒëŸ¬ì‹œ
}

// ê°œì„ ëœ íŒ¨í„´
bool need_rare_handling = rare_condition;
if (__builtin_expect(need_rare_handling, 0)) {  // ì˜ˆì¸¡ íŒíŠ¸ ì œê³µ
    handle_rare_case();
}
```

### 8.3 SIMD í™œìš©

**ë²¡í„°í™”ëœ ì—°ì‚°:**
```c
// ìŠ¤ì¹¼ë¼ ì—°ì‚° (ë¹„íš¨ìœ¨ì )
void add_arrays(float *a, float *b, float *result, int n) {
    for (int i = 0; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}

// ë²¡í„°í™”ëœ ì—°ì‚° (SIMD)
#include <immintrin.h>
void add_arrays_simd(float *a, float *b, float *result, int n) {
    int i = 0;
    for (; i <= n - 8; i += 8) {  // 8ê°œ float ë™ì‹œ ì²˜ë¦¬
        __m256 va = _mm256_load_ps(&a[i]);
        __m256 vb = _mm256_load_ps(&b[i]);
        __m256 vc = _mm256_add_ps(va, vb);
        _mm256_store_ps(&result[i], vc);
    }
    // ë‚¨ì€ ìš”ì†Œ ì²˜ë¦¬
    for (; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}
```

---

## 9. ë””ë²„ê¹…ê³¼ ì„±ëŠ¥ ë¶„ì„

### 9.1 í”„ë¡œíŒŒì¼ë§ ë„êµ¬

**Linux perf:**
```bash
# CPU ìºì‹œ ë¯¸ìŠ¤ ë¶„ì„
perf stat -e cache-misses,cache-references ./program

# í•¨ìˆ˜ë³„ ì„±ëŠ¥ ë¶„ì„
perf record -g ./program
perf report
```

**Intel VTune:**
- ìºì‹œ ë¯¸ìŠ¤ìœ¨ ë¶„ì„
- ë¶„ê¸° ì˜ˆì¸¡ ì‹¤íŒ¨ìœ¨ ì¸¡ì •
- ë©”ëª¨ë¦¬ ì ‘ê·¼ íŒ¨í„´ ë¶„ì„

### 9.2 ì•„í‚¤í…ì²˜ ì˜ì¡´ì  ìµœì í™”

**CPU íŠ¹ì„± ê³ ë ¤:**
```c
// CPU ìºì‹œ ë¼ì¸ í¬ê¸° ê³ ë ¤
#define CACHE_LINE_SIZE 64

struct alignas(CACHE_LINE_SIZE) CacheAlignedData {
    int data;
    // íŒ¨ë”©ìœ¼ë¡œ ìºì‹œ ë¼ì¸ í¬ê¸° ë§ì¶¤
};

// False sharing ë°©ì§€
struct ThreadData {
    alignas(CACHE_LINE_SIZE) int counter1;
    alignas(CACHE_LINE_SIZE) int counter2;  // ë‹¤ë¥¸ ìºì‹œ ë¼ì¸ì— ë°°ì¹˜
};
```

---

## 10. ë¯¸ë˜ ì „ë§

### 10.1 ì–‘ì ì»´í“¨íŒ… ì•„í‚¤í…ì²˜

**ì „í†µì  vs ì–‘ì ì»´í“¨í„°:**
- **í´ë˜ì‹:** ë¹„íŠ¸ ê¸°ë°˜ ê²°ì •ì  ì—°ì‚°
- **ì–‘ì:** íë¹„íŠ¸ ê¸°ë°˜ í™•ë¥ ì  ì—°ì‚°
- **ì‘ìš©:** ì•”í˜¸í™”, ìµœì í™” ë¬¸ì œ, ì‹œë®¬ë ˆì´ì…˜

### 10.2 ë‰´ë¡œëª¨í”½ ì»´í“¨íŒ…

**ë‡Œ ì˜ê° ì•„í‚¤í…ì²˜:**
- ì¸ê°„ ë‡Œ êµ¬ì¡° ëª¨ë°©
- ë³‘ë ¬ ì²˜ë¦¬ì™€ ì ì‘ í•™ìŠµ
- ë‚®ì€ ì „ë ¥ ì†Œë¹„

### 10.3 ê´‘ ì»´í“¨íŒ…

**ê´‘ì ê¸°ë°˜ ì—°ì‚°:**
- ì „ì ëŒ€ì‹  ë¹› ì‚¬ìš©
- ê·¹í•œì˜ ë³‘ë ¬ ì²˜ë¦¬ ê°€ëŠ¥
- ì „ë ¥ íš¨ìœ¨ ê·¹ëŒ€í™”

---

## 11. ê²°ë¡ : ì™œ ì•„í‚¤í…ì²˜ë¥¼ ì•Œì•„ì•¼ í•˜ëŠ”ê°€?

### 11.1 ì„±ëŠ¥ ìµœì í™”ì˜ ê¸°ì´ˆ

**ì•„í‚¤í…ì²˜ ì§€ì‹ì˜ ì‹¤ìš©ì  ê°€ì¹˜:**
- **ìºì‹œ ì¹œí™”ì  ì½”ë“œ ì‘ì„±:** ë©”ëª¨ë¦¬ ê³„ì¸µ ì´í•´
- **ë³‘ë ¬í™” ì „ëµ ìˆ˜ë¦½:** SIMD, MIMD í™œìš©
- **I/O ë³‘ëª© í•´ì†Œ:** ì¸í„°ëŸ½íŠ¸ì™€ DMA ì´í•´

### 11.2 ë¬¸ì œ í•´ê²° ëŠ¥ë ¥ í–¥ìƒ

**ì‹œìŠ¤í…œì  ì‚¬ê³ :**
- í•˜ë“œì›¨ì–´ ì œì•½ ì´í•´
- ì†Œí”„íŠ¸ì›¨ì–´-í•˜ë“œì›¨ì–´ ìƒí˜¸ì‘ìš© íŒŒì•…
- ì„±ëŠ¥ ë³‘ëª© ì›ì¸ ë¶„ì„

### 11.3 ë¯¸ë˜ ê¸°ìˆ  ì ì‘ë ¥

**ìƒˆë¡œìš´ íŒ¨ëŸ¬ë‹¤ì„ ì´í•´:**
- ìƒˆë¡œìš´ ì•„í‚¤í…ì²˜ì˜ ë“±ì¥
- ê¸°ì¡´ ì§€ì‹ì˜ í™•ì¥ ì ìš©
- í˜ì‹ ì  ì†”ë£¨ì…˜ ì„¤ê³„

---

*"ì»´í“¨í„° ì•„í‚¤í…ì²˜ëŠ” í•˜ë“œì›¨ì–´ì™€ ì†Œí”„íŠ¸ì›¨ì–´ì˜ ë‹¤ë¦¬ë‹¤. ì´ ë‹¤ë¦¬ë¥¼ ê±´ë„ˆì§€ ëª»í•˜ë©´ ì§„ì •í•œ ì—”ì§€ë‹ˆì–´ê°€ ë  ìˆ˜ ì—†ë‹¤."*

> ì»´í“¨í„° ì•„í‚¤í…ì²˜ë¥¼ ì´í•´í•˜ë©´ ì½”ë“œ í•œ ì¤„ì´ ì‹œìŠ¤í…œ ì „ì²´ ì„±ëŠ¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. íš¨ìœ¨ì ì¸ ì†Œí”„íŠ¸ì›¨ì–´ëŠ” í•˜ë“œì›¨ì–´ë¥¼ ì¡´ì¤‘í•˜ëŠ” ë°ì„œ ì‹œì‘ë©ë‹ˆë‹¤.