# 💰 컴퓨터가 돈을 계산 못하는 이유: 숫자 표현의 함정

> **이 문서의 목표:** 컴퓨터가 실수를 표현하는 방식(부동 소수점)의 한계를 이해하고, **정확한 수치 계산(특히 돈 계산)**을 위한 올바른 해결책을 습득한다.

---

## 0. 핵심 질문으로 시작하기

1.  **왜 0.1 + 0.2 ≠ 0.3 인가?** → 2진수로는 0.1과 0.2를 정확히 표현할 수 없어 무한 소수가 되고, 이를 자르는 과정에서 오차가 발생하기 때문.
2.  **금융 계산에서 float/double을 쓰면 안 되는 이유는?** → 미세한 오차가 누적되어 금전적 손실이나 데이터 불일치를 유발할 수 있음.
3.  **정수는 항상 안전한가?** → 정밀도는 안전하지만, **오버플로우(Overflow)**를 주의해야 함.
4.  **BigDecimal은 만능인가?** → 정확성은 보장하지만 속도가 느리고 코드가 복잡해짐 (트레이드오프).

---

## 1. [개념 정의]: 컴퓨터의 숫자와 인간의 숫자 (Why)

인간은 10진수(0~9)를 쓰지만, 컴퓨터는 2진수(0, 1)를 씁니다.
이 근본적인 차이 때문에 **10진수의 소수를 2진수로 변환할 때 딱 떨어지지 않는 경우**가 생깁니다.

### 1.1 충격적인 현실 (Problem)
```java
System.out.println(0.1 + 0.2); 
// 출력: 0.30000000000000004
// 0.3이 아님!
```
이런 오차는 쇼핑몰 결제, 은행 이자 계산, 게임 데미지 계산 등에서 치명적인 버그를 만듭니다.

---

## 2. [원리/구조]: 부동 소수점과 IEEE 754 (How)

### 2.1 부동 소수점 (Floating Point)
소수점의 위치가 고정되지 않고 둥둥 떠다닌다(Floating)는 뜻입니다.
컴퓨터는 실수를 `부호(Sign) + 지수(Exponent) + 가수(Mantissa)` 형태로 저장합니다. (IEEE 754 표준)

*   **한계**: 유효 자릿수가 제한되어 있어, 그 범위를 넘어가면 **근사값**으로 저장합니다.
*   **10진수 0.1의 비극**: 2진수로는 `0.0001100110011...` (무한 반복)이 됩니다. 결국 어딘가에서 잘라야 하고, 여기서 오차가 생깁니다.

### 2.2 정수의 오버플로우
정수는 오차는 없지만, 그릇의 크기가 정해져 있습니다.

```mermaid
graph LR
    A[Max Value] -->|+1| B[Min Value]
    B -->|Overflow| A
```

*   `int` (32bit): 약 ±21억. 이걸 넘으면 **음수**가 되어버립니다.
*   `long` (64bit): 약 ±922경. 훨씬 크지만 무한하진 않습니다.

---

## 3. [실전/구현]: 올바른 계산법 (What)

### 3.1 돈 계산은 무조건 `BigDecimal` (Java 기준)

```java
// ❌ 절대 금지: double로 돈 계산
double price = 1.1;
double tax = 0.1;
// price + tax = 1.2000000000000002 (오차 발생)

// ✅ 권장: BigDecimal 사용 (반드시 String 생성자 사용!)
BigDecimal price = new BigDecimal("1.1");
BigDecimal tax = new BigDecimal("0.1");
BigDecimal total = price.add(tax); // 1.2 (정확함)
```

> [!WARNING]
> `new BigDecimal(0.1)` 처럼 숫자를 바로 넣으면 안 됩니다. 0.1 자체가 이미 오차가 있는 `double`이라서 오차를 그대로 가져옵니다. **반드시 문자열(`"0.1"`)로 넣으세요.**

### 3.2 실수 비교는 `epsilon` 사용
부동 소수점끼리 `==` 로 비교하면 안 됩니다.

```java
// ❌ 버그 발생
if (a == b) { ... } 

// ✅ 오차 범위(Epsilon) 내에 있는지 확인
if (Math.abs(a - b) < 0.00001) { ... }
```

### 3.3 JavaScript의 함정
JS는 모든 숫자가 `Number` (double) 입니다. 아주 큰 정수를 다룰 때는 `BigInt`를 써야 합니다.

```javascript
// JS의 정수 안전 범위: Number.MAX_SAFE_INTEGER (약 9000조)
const big = 9007199254740991n; // BigInt 사용
```

---

## 4. 🎯 1분 요약

1.  **부동 소수점의 한계**: 컴퓨터는 소수를 완벽하게 저장하지 못하고 **근사값**으로 저장한다.
2.  **돈 계산**: 정확성이 생명인 금융/결제 로직에서는 `float`, `double`을 절대 쓰지 말고 **`BigDecimal`** (또는 정수형으로 변환)을 사용한다.
3.  **생성자 주의**: `BigDecimal`을 만들 때도 숫자가 아닌 **문자열(String)**로 값을 넘겨야 정확하다.
4.  **오버플로우**: 정수형을 쓸 때는 데이터의 최대 크기를 예상하고 적절한 타입(`int` vs `long`)을 골라야 한다.

---

## 5. 📝 자가 점검 질문

1.  **Java에서 `new BigDecimal(0.1)`과 `new BigDecimal("0.1")`의 차이는?**
    → 전자는 `double` 0.1(근사값)을 그대로 가져와 오차가 있고, 후자는 문자열 "0.1"을 정확히 해석하여 오차가 없다.
2.  **2의 보수법을 사용하는 주된 이유는?**
    → 덧셈 회로 하나로 뺄셈까지 처리하기 위해 (음수 표현 및 연산의 효율성).
3.  **오버플로우(Overflow)를 방지하는 방법은?**
    → 더 큰 자료형(`long`)을 쓰거나, 연산 전에 범위를 체크하는 라이브러리(`Math.addExact`)를 사용한다.
4.  **부동 소수점 비교에서 `a == b`가 위험한 이유는?**
    → 아주 미세한 비트 차이로 인해, 논리적으로 같아야 할 값이 컴퓨터 내부에서는 다를 수 있기 때문. (`Epsilon` 비교 필요)
