# 💡 알고리즘: “외우지 않고 이해하는” 실전 가이드

> **목표:** 문제를 봤을 때 “어떤 도구(알고리즘/자료구조)를 꺼낼지”를 **판단**할 수 있게 만들기  
> **핵심 질문:** 왜 이 선택이 맞고, 언제 틀리는가?

이 문서는 **암기용 목록**이 아니라, 아래 3가지를 빠르게 확인하도록 구성했습니다.

- **문제 신호**: 입력/조건에서 어떤 단서가 보이는가?
- **전제 조건**: 정렬이 필요한가? 그래프 가중치가 있는가? 중복 계산이 있는가?
- **트레이드오프**: 시간/메모리/구현 난이도 중 무엇을 희생하는가?

---

## 0. 🧭 빠른 선택 지도 (문제 신호 → 체크리스트 → 도구)

아래 표는 “정답 알고리즘”이 아니라 **첫 후보를 고르는 지도**입니다.  
표에서 고른 다음, 바로 아래 “전제 체크”를 통과하면 확률이 크게 올라갑니다.

| 문제 신호(문장/조건) | 1순위 후보 | 전제 체크(틀리면 바뀜) | 핵심 이유 |
|---|---|---|---|
| **"존재 여부 / 찾기"** | 선형 탐색 / 해시 / 이진 탐색 | 정렬돼 있나? 중복/빈도도 필요하나? | 조건에 따라 `O(n)` → `O(1)`/`O(log n)`로 개선 |
| **"정렬하면 쉬워질 것 같다"** | 정렬(`O(n log n)`) | 정렬이 허용되나(원본 유지)? | 정렬은 문제 구조를 단순화(경계/순서/인접) |
| **"매번 최소/최대가 필요"** | 힙(우선순위 큐) | 업데이트가 잦은가? | 매 단계 최솟값/최댓값 추출이 빠름 |
| **"최단거리"** | BFS / 다익스트라 | 간선 가중치가 0/1/양수/음수? | 가중치가 선택을 결정 |
| **"경우의 수 + 중복"** | DP | 같은 상태를 반복 계산하나? | 중복 제거가 본질 |
| **"지금 최선 = 전체 최선"** | 그리디 | 증명(교환/컷) 가능? 반례가 쉬운가? | 성립 조건이 있을 때만 정답 |

### 0.1 시작 전에 딱 4개만 확인하기 (전제 체크)

- **정렬돼 있나?** → 이진 탐색/투 포인터 가능 여부가 갈림
- **가중치가 있나?** → BFS vs 다익스트라가 갈림
- **중복 계산이 있나?** → DP가 갈림
- **온라인(스트리밍)인가?** → 한 번만 훑어야 하면 힙/슬라이딩 윈도우/그리디 성격이 강해짐

---

## 1. ⚡ 빅오(Big-O): 알고리즘의 “연비” 보기

Big-O는 “몇 초 걸리냐”가 아니라 **입력 크기 \(n\)** 이 커질 때 **성장 속도**를 봅니다.

### 1.1 직관으로 보는 성장 속도

| 표기 | 느낌(직관) | 대표 예 |
|---|---|---|
| **O(1)** | 항상 일정 | 배열 인덱스 접근 |
| **O(log n)** | 매번 반으로 줄임 | 이진 탐색 |
| **O(n)** | 한 번 훑음 | 단일 루프 |
| **O(n log n)** | “정렬급” | 병합 정렬, 퀵 정렬(평균) |
| **O(n²)** | 쌍 비교/모든 조합(2중 루프) | 모든 pair 검사 |
| **O(2ⁿ)** | 조합 폭발 | 순진한 부분집합/재귀 |

### 1.2 제약을 볼 때 바로 떠올리는 감(대략)

> 코테/실무에서 자주 쓰는 감각입니다. 환경에 따라 달라질 수 있지만 방향을 잡기엔 유용합니다.

- **\(n \le 10^3\)**: `O(n^2)`도 고려 가능
- **\(n \le 10^5\)**: 보통 `O(n log n)` 또는 `O(n)`
- **\(n \le 10^6\)**: 보통 `O(n)` 중심(상수 중요)

### 1.3 Big-O에서 자주 놓치는 것

- **정렬 비용**: “한 번 정렬”은 `O(n log n)`이지만, 그 이후 문제를 `O(n)`으로 푸는 경우가 많습니다.
- **메모리도 제약**: `O(n log n)`이어도 메모리가 커서 실패할 수 있습니다.
- **상수항/캐시/언어 구현**: 같은 `O(n)`이라도 실제 시간은 크게 차이 날 수 있습니다.

---

## 2. 📚 정렬(Sorting): 정렬은 “정답을 찾기 위한 전처리”

정렬의 목적은 “예쁘게 나열”이 아니라 **문제를 더 쉬운 형태로 바꾸는 것**입니다.

정렬이 특히 강한 문제 유형:

- **인접 관계**: “가장 가까운 두 수”, “구간 겹침”
- **경계 찾기**: 이진 탐색(lower/upper bound)
- **단조성**: 투 포인터/슬라이딩 윈도우

### 2.1 면접에서 자주 묻는 정렬 포인트

| 알고리즘 | 평균 시간 | 최악 시간 | 추가 메모리 | 안정 정렬(Stable) | 제자리(In-place) | 언제 고려? |
|---|---:|---:|---:|:---:|:---:|---|
| 버블 | \(n^2\) | \(n^2\) | 작음 | ✅ | ✅ | 학습용 |
| 삽입 | \(n^2\) | \(n^2\) | 작음 | ✅ | ✅ | **거의 정렬됨**, 데이터 작음 |
| 퀵 | \(n \log n\) | \(n^2\) | 작음 | ❌(일반적으로) | ✅ | 평균 빠름(대부분의 라이브러리는 최악을 회피하도록 개선됨) |
| 병합 | \(n \log n\) | \(n \log n\) | 큼 | ✅ | ❌ | 최악도 안정적, 안정 정렬이 필요할 때 |

> **안정 정렬(Stable)**: 같은 키를 가진 원소들의 상대 순서가 유지되는 정렬

### 2.2 구현 관점에서의 현실 팁

- 코테/실무에서는 보통 **내장 정렬**을 쓰고, “왜 정렬을 했는지/정렬 후 어떻게 푸는지”가 더 중요합니다.
- 정렬 알고리즘 자체 구현은 “요구될 때”만(개념 설명용) 준비하면 충분합니다.

---

## 3. 🔍 탐색(Search): “정렬 여부”가 선택을 바꾼다

### 3.1 선형 탐색 (Linear Search)

- **언제**: 정렬이 아니거나, 데이터가 매우 작거나, 한 번 훑으면서 다른 계산도 같이 할 때
- **시간**: \(O(n)\)

### 3.2 이진 탐색 (Binary Search)

- **전제**: **정렬되어 있어야 함**
- **직관**: 답이 있을 수 없는 절반을 매번 버림(Up/Down 게임)
- **시간**: \(O(\log n)\)

```python
def binary_search(arr, target):
    # arr must be sorted in ascending order.
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid  # Found.
        if arr[mid] < target:
            left = mid + 1  # Search right half.
        else:
            right = mid - 1  # Search left half.

    return -1  # Not found.
```

### 3.3 실전에서 더 많이 쓰는 형태: “값 찾기”보다 “경계 찾기”

이진 탐색은 “target의 인덱스”보다 **구간의 경계**를 찾는 데 훨씬 자주 씁니다.

- **lower_bound**: `target` **이상**이 처음 나오는 위치
- **upper_bound**: `target` **초과**가 처음 나오는 위치

```python
def lower_bound(arr, target):
    # First index i such that arr[i] >= target.
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    return left


def upper_bound(arr, target):
    # First index i such that arr[i] > target.
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    return left
```

**왜 경계가 중요할까?**

- “값이 몇 개 있는지”: `upper_bound - lower_bound`
- “조건을 만족하는 최소/최대 값 찾기”: **답이 단조(monotonic)** 하다면 이진 탐색 가능

### 3.4 해시(Hash Map / Dictionary): “빠른 조회/카운팅”의 기본기

정렬/이진탐색이 “순서”를 쓰는 도구라면, 해시는 “키로 바로 찾기”에 강합니다.

- **언제**: 존재 여부, 빈도 카운팅, 그룹핑, 빠른 매핑(값 → 인덱스)
- **시간(평균)**: 조회/삽입/삭제가 보통 \(O(1)\)
- **대가**: 메모리를 더 쓰고, 순서가 필요하면 추가 처리가 필요할 수 있음

**실전 체크리스트**

- “정렬된 순서”가 꼭 필요하지 않은가? → 필요 없으면 해시가 더 단순한 경우가 많음
- “중복 개수”가 필요한가? → `count[key] += 1` 패턴이 자주 정답

### 3.5 힙(우선순위 큐): “매번 최솟값/최댓값”이 필요할 때

- **언제**: k번째 최솟값/최댓값, 실시간으로 최소/최대 갱신, 다익스트라 같은 최단거리
- **연산**: 삽입/삭제(최솟값 추출)가 보통 \(O(\log n)\), 최솟값 확인은 \(O(1)\)

**실전 체크리스트**

- “정렬 한 번”으로 끝나는가, 아니면 **중간중간 계속 최소/최대를 뽑아야 하는가?**  
  - 계속 뽑아야 한다면 힙이 유리한 경우가 많음

### 3.6 투 포인터 / 슬라이딩 윈도우: “구간”을 한 번에 훑기

두 포인터는 “왼쪽/오른쪽 경계를 움직이며 구간을 유지”하는 방식입니다.

- **투 포인터(주로 정렬 배열)**: 합/차/조건을 만족하는 pair 찾기 (`i`, `j`를 안쪽으로 이동)
- **슬라이딩 윈도우(주로 연속 구간)**: 고정/가변 길이 구간의 최대/최소/개수

**전제(자주 필요한 것)**

- 조건이 **단조**여야 포인터가 “되돌아가지 않고” 앞으로만 가도 정답이 됩니다.
- “연속 구간”이 아니라면 슬라이딩 윈도우가 안 맞을 수 있습니다.

---

## 4. 🔄 재귀(Recursion)와 DP(동적 프로그래밍): “중복”을 다루는 방식

### 4.1 재귀: 큰 문제를 작은 문제로 표현하기

재귀는 표현력이 좋지만, 아래 2개가 없으면 위험합니다.

- **Base case**: 언제 멈추는가?
- **Progress**: 매 호출마다 문제 크기가 실제로 줄어드는가?

> 위험 신호: 같은 상태를 다시 호출 / 멈춤 조건이 입력에 의해 보장되지 않음 / 재귀 깊이가 너무 큼(스택 오버플로우)

### 4.2 DP: 같은 부분문제를 반복해서 푸는가?

DP는 “재귀를 예쁘게”가 아니라, **중복 계산을 제거**하는 전략입니다.  
성립하는 대표 조건은 2가지입니다.

- **최적 부분 구조**: 큰 문제의 최적해가 작은 문제의 최적해로부터 구성됨
- **중복 부분 문제**: 같은 부분 문제가 여러 번 등장함

### 4.3 DP를 잡는 4단계(실전 체크리스트)

- **상태(State)**: 무엇을 기억하면 이후 결정을 내릴 수 있나? (예: `dp[i]`는 i번째까지의 최적값)
- **전이(Transition)**: 상태를 어떻게 이전 상태로부터 만들까? (예: `dp[i] = min(dp[i-1], dp[i-2]) + cost[i]`)
- **초기값(Base)**: 가장 작은 입력에서 정답은?
- **정답(Answer)**: 어떤 상태를 출력하면 되는가?

### 4.4 구현 스타일 2가지

- **메모이제이션(Memoization, Top-down)**: 필요할 때 계산해서 저장(재귀 + 캐시)
- **타뷸레이션(Tabulation, Bottom-up)**: 작은 것부터 차곡차곡 채움(반복문)

> 코테에서는 Bottom-up이 스택 오버플로우 위험이 적고 디버깅이 쉬운 편입니다.

---

## 5. 🌐 그래프(Graph): “연결(관계)”을 모델링하는 도구

그래프는 지하철 노선, 친구 관계, 의존성처럼 **관계(간선)**가 핵심인 문제를 표현합니다.

### 5.1 그래프를 어떻게 저장할까?

| 표현 | 장점 | 단점 | 언제 쓰나? |
|---|---|---|---|
| 인접 리스트 | 메모리 효율 좋음, 탐색 빠름 | 구현이 조금 더 필요 | 대부분의 코테/실무 |
| 인접 행렬 | 구현 단순 | 메모리 큼(\(O(n^2)\)) | 노드 수가 매우 작을 때 |

### 5.2 BFS vs DFS: “최단거리”가 갈림길

| 방식 | 직관 | 주로 푸는 문제 | 자료구조 |
|---|---|---|---|
| **BFS** | 가까운 곳부터 원형 확장 | **최단거리(간선 가중치가 모두 동일/없음)** | 큐 |
| **DFS** | 한 길로 끝까지, 막히면 백트랙 | 경로 존재, 사이클 탐지, 백트래킹 | 스택/재귀 |

**선택 기준**

- **최단거리**이고 간선 가중치가 모두 동일(예: 1)이라면 → **BFS**
- 모든 경우를 탐색하거나(백트래킹), 깊은 경로를 파야 한다면 → **DFS**

### 5.3 “최단거리”에서 가장 흔한 실수 2가지

- **가중치가 있는데 BFS를 쓰는 실수**: 가중치가 있으면 BFS가 최단을 보장하지 않습니다.
- **음수 가중치를 다익스트라로 푸는 실수**: 음수 간선이 있으면 다익스트라가 깨집니다.

### 5.4 최단거리 알고리즘 선택표(가중치로 결정)

| 상황(가중치) | 보통의 선택 | 핵심 메모 |
|---|---|---|
| 가중치 없음/모두 1 | BFS | 레벨(거리)이 곧 정답 |
| 가중치가 0 또는 1 | 0-1 BFS | 덱(deque)로 빠르게 처리 가능 |
| 가중치가 모두 **0 이상** | 다익스트라 | 우선순위 큐(힙)로 구현하는 경우가 많음 |
| 음수 가중치 존재 | 벨만-포드 | 느리지만 음수 처리 가능(음수 사이클도 탐지) |

---

## 6. 💰 그리디(Greedy): “지금 최선”이 “전체 최선”이 될 때만

그리디는 빠르고 단순하지만, **문제에 그리디가 통하는 구조가 있을 때만** 정답을 보장합니다.

### 6.1 그리디를 의심해야 하는 순간(반례 필터)

- “지금 최선”이 나중에 큰 손해로 이어질 수 있는가?
- 선택이 이후 선택 공간을 크게 바꾸는가?
- 작은 반례를 손으로 만들기 쉬운가?

### 6.2 예시: 거스름돈(특정 동전 체계에서만 정답)

동전이 `500, 100, 50, 10`처럼 특정 체계에서는 그리디가 최적이지만,  
임의의 동전 체계에서는 반례가 생길 수 있습니다.

> 그리디를 쓰면 좋은 신호: “정렬 + 가장 이른/가장 작은/가장 큰 것부터 선택”이 자연스럽고, 교환 논리로 설명이 되는 경우

---

## 7. 🚀 실전 문제 풀이 루틴(암기 대신 ‘생각의 순서’)

1. **문제 재정의**: 입력/출력, 제약, 예외(빈 입력/최대값), 정답의 형태를 명확히 하기  
2. **모델링**: 배열/정렬/그래프/DP 중 어떤 형태로 바라보면 단순해지는지 결정  
3. **가장 단순한 해(Brute Force)**: “정답이 나오는 기준점”을 먼저 만들기  
4. **병목 찾기**: 시간/메모리 병목이 어디인지 Big-O로 짚기  
5. **도구 선택**: 정렬/해시/힙/이진탐색(경계)/DP/그래프 탐색 중 무엇이 병목을 줄이는지 결정  
6. **검증**: 경계값 + 반례(특히 그리디/이진탐색 경계/DP 인덱스/그래프 방문 처리)로 테스트

> **마지막 조언:** 알고리즘은 “외우는 목록”이 아니라, **문제를 단순화하는 관점을 고르는 일**입니다.
