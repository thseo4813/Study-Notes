# 💡 알고리즘: 외우지 않고 이해하는 실전 가이드

> **목표:** "어떤 문제에서 어떤 도구(알고리즘/자료구조)를 꺼낼지"를 **판단**할 수 있게 만드는 것

이 문서는 암기용 정리가 아니라, 아래 질문에 답하도록 구성했습니다.

- **이 상황에서 왜 이걸 쓰지?**
- **전제가 뭐지? (정렬 필요? 그래프 가중치? 중복 계산?)**
- **시간/메모리/구현 난이도 트레이드오프는 뭐지?**

---

## 0. 🧭 빠른 선택 지도 (문제 유형 → 도구)

| 문제 신호 | 보통의 선택 | 핵심 이유 |
|---|---|---|
| "찾기/존재 여부" | 선형 탐색 / 이진 탐색 | 정렬 여부에 따라 갈림 |
| "정렬해서 규칙 찾기" | `O(n log n)` 정렬 | 정렬 자체가 문제를 단순화 |
| "최소/최댓값이 매 단계에 필요" | 우선순위 큐(힙) | 매번 최소/최대 추출이 빠름 |
| "최단거리" | BFS / 다익스트라 | 가중치 유무가 기준 |
| "경우의 수 + 중복" | DP | 같은 부분문제가 반복됨 |
| "지금 최선"이 전체 최선으로 이어짐 | 그리디 | 성립 조건이 있을 때만 정답 |

---

## 1. ⚡ 빅오(Big-O): 알고리즘의 '연비' 측정하기

알고리즘 성능은 컴퓨터 사양에 따라 달라지는 "초"가 아니라,
**입력 크기 \(n\)이 커질 때 연산량이 어떻게 증가하는지**로 비교합니다.

### 1.1 직관으로 보는 성장 속도

| 표기 | 느낌 | 대표 예 |
|---|---|---|
| **O(1)** | 입력이 커져도 일정 | 배열 인덱스 접근 |
| **O(log n)** | 반씩 줄이는 구조 | 이진 탐색 |
| **O(n)** | 한 번 훑기 | 단일 for-loop |
| **O(n log n)** | 정렬급 | 병합/퀵(평균) |
| **O(n²)** | 쌍을 다 비교 | 이중 for-loop |
| **O(2ⁿ)** | 조합 폭발 | 순진한 부분집합/재귀 |

### 1.2 Big-O를 볼 때 자주 놓치는 것

- **상수항/캐시/언어 구현**: `O(n)`이라도 상수가 큰 알고리즘이 느릴 수 있지만, \(n\)이 커질수록 Big-O가 지배합니다.
- **입력 제약이 작으면**: `O(n²)`도 \(n \le 2,000\) 정도면 통과하는 경우가 흔합니다.
- **시간만이 전부가 아님**: `O(n log n)`이어도 메모리를 너무 쓰면 실패할 수 있습니다.

---

## 2. 📚 정렬(Sorting): "정렬"은 그 자체가 문제 풀이 전략

정렬은 단순히 예쁘게 나열하는 게 아니라, **문제를 단순하게 만드는 전처리**입니다.

예) "가장 가까운 두 수", "중복 제거", "투 포인터", "이진 탐색"은 정렬과 궁합이 좋습니다.

### 2.1 정렬 선택 기준(면접에서 자주 묻는 포인트)

| 알고리즘 | 평균 시간 | 최악 시간 | 추가 메모리 | 안정 정렬(Stable) | 제자리(In-place) | 언제 고려? |
|---|---:|---:|---:|:---:|:---:|---|
| 버블 | \(n^2\) | \(n^2\) | 작음 | ✅ | ✅ | 학습용 |
| 삽입 | \(n^2\) | \(n^2\) | 작음 | ✅ | ✅ | **거의 정렬됨**, 데이터 작음 |
| 퀵 | \(n \log n\) | \(n^2\) | 작음 | ❌(일반적으로) | ✅ | 평균 빠름, 실무/라이브러리에서 자주 사용 |
| 병합 | \(n \log n\) | \(n \log n\) | 큼 | ✅ | ❌ | 최악도 안정적, 링크드리스트/외부정렬에 강함 |

> **안정 정렬(Stable)**: 같은 키를 가진 원소들의 상대적 순서가 유지되는 정렬

### 2.2 직관적인 정렬(느리지만 이해가 쉬움)

#### 버블 정렬 (Bubble Sort)

- **직관**: 옆 원소끼리 비교해서 큰 값을 뒤로 "밀어" 보냄
- **핵심 한 줄**: "가장 큰 값이 한 번의 패스(pass)마다 맨 뒤로 간다"
- **현실**: 학습용(실무/코테에서는 거의 사용하지 않음)

#### 삽입 정렬 (Insertion Sort)

- **직관**: 왼쪽은 "이미 정렬된 손패", 새 카드를 적절한 위치에 끼워넣음
- **강점**: 거의 정렬된 데이터에서는 매우 빠를 수 있음(실제로 `TimSort` 같은 하이브리드 정렬이 이 성질을 활용)

### 2.3 효율적인 정렬(실무/코테에서 자주 씀)

#### 퀵 정렬 (Quick Sort)

- **직관**: 기준(pivot) 하나를 고르고, 작은 값/큰 값으로 파티션을 나눔 → 양쪽을 재귀적으로 반복
- **장점**: 평균적으로 빠르고 메모리 효율이 좋음(제자리 정렬 가능)
- **주의**: pivot 선택이 나쁘면 최악 \(n^2\)

#### 병합 정렬 (Merge Sort)

- **직관**: 반으로 계속 쪼개서(분할) 각 조각을 정렬한 뒤, 두 정렬된 리스트를 합치며(정복) 전체를 정렬
- **장점**: 최악에도 \(n \log n\) 보장, 안정 정렬
- **단점**: 추가 메모리 사용

---

## 3. 🔍 탐색(Search): "정렬 여부"가 선택을 바꾼다

### 3.1 선형 탐색 (Linear Search)

- **언제**: 정렬이 되어 있지 않거나, 자료구조 특성상 하나씩 봐야 할 때
- **시간**: \(O(n)\)

### 3.2 이진 탐색 (Binary Search)

- **전제**: **정렬되어 있어야 함**
- **직관**: 답이 있을 수 없는 절반을 매번 버림(Up/Down 게임)
- **시간**: \(O(\log n)\)

```python
def binary_search(arr, target):
    # arr must be sorted in ascending order.
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid  # Found.
        if arr[mid] < target:
            left = mid + 1  # Search right half.
        else:
            right = mid - 1  # Search left half.

    return -1  # Not found.
```

### 3.3 이진 탐색을 실전에서 제대로 쓰는 법

- **"정확히 target 찾기"**뿐 아니라,
  - **lower_bound**(target 이상이 처음 나오는 위치)
  - **upper_bound**(target 초과가 처음 나오는 위치)
  같은 형태로 "구간의 경계"를 찾는 데 특히 많이 씁니다.

---

## 4. 🔄 재귀(Recursion)와 DP(동적 프로그래밍): "중복"을 다루는 방식

### 4.1 재귀: 큰 문제를 작은 문제로

재귀는 표현력이 좋지만, 아래 2개가 없으면 바로 터집니다.

- **Base case**: 언제 멈추는가?
- **Progress**: 매 호출마다 문제 크기가 실제로 줄어드는가?

> 위험 신호: "같은 상태를 다시 호출" / "멈추는 조건이 데이터에 의해 보장되지 않음"

### 4.2 DP: 같은 문제를 반복해서 푸는가?

DP가 성립하는 대표 조건은 2가지입니다.

- **최적 부분 구조**: 큰 문제의 최적해가 작은 문제의 최적해로부터 구성됨
- **중복 부분 문제**: 같은 부분 문제가 여러 번 등장함

DP는 "재귀를 예쁘게"가 아니라, **중복 계산을 제거**하는 전략입니다.

#### 4.2.1 피보나치로 보는 차이 (중복 제거의 의미)

- 순진한 재귀는 `F(3)` 같은 값을 여러 번 다시 계산합니다.
- DP는 한 번 계산한 값을 저장해서 재사용합니다.

**성능 변화 예시**

- 순진한 재귀: \(O(2^n)\)
- DP(메모이제이션/테이블): \(O(n)\)

#### 4.2.2 DP 구현 스타일 2가지

- **메모이제이션(Memoization)**: "필요해질 때 계산해서 저장"(Top-down)
- **타뷸레이션(Tabulation)**: "작은 것부터 차곡차곡 채움"(Bottom-up)

> 코테에서는 Bottom-up이 스택 오버플로우 위험이 적고 디버깅이 쉬운 편입니다.

---

## 5. 🌐 그래프(Graph): "연결"을 모델링하는 도구

그래프는 지하철 노선, 친구 관계, 의존성 등 **관계(간선)**가 핵심인 문제를 표현합니다.

### 5.1 그래프를 어떻게 저장할까?

| 표현 | 장점 | 단점 | 언제 쓰나? |
|---|---|---|---|
| 인접 리스트 | 메모리 효율 좋음, 탐색 빠름 | 구현이 조금 더 필요 | 대부분의 코테/실무 |
| 인접 행렬 | 구현 단순 | 메모리 큼(\(O(n^2)\)) | 노드 수가 매우 작을 때 |

### 5.2 BFS vs DFS: "최단거리"가 갈림길

| 방식 | 직관 | 주로 푸는 문제 | 자료구조 |
|---|---|---|---|
| **BFS** | 가까운 곳부터 원형 확장 | **최단거리(간선 가중치가 모두 동일/없음)** | 큐 |
| **DFS** | 한 길로 끝까지, 막히면 백트랙 | 경로 존재, 사이클 탐지, 백트래킹 | 스택/재귀 |

**선택 기준**

- **"최단거리"**가 필요하고 간선 가중치가 동일(1)이라면 → **BFS**
- 모든 경우를 탐색하거나(백트래킹), 경로를 깊게 파야 한다면 → **DFS**

> 가중치가 있는 최단거리는 보통 BFS가 아니라 다익스트라/벨만-포드를 씁니다.

---

## 6. 💰 그리디(Greedy): "지금 최선"이 "전체 최선"이 될 때만

그리디는 빠르고 단순하지만, **문제에 그리디가 통하는 구조가 있을 때만** 정답을 보장합니다.

### 6.1 그리디를 의심해야 하는 순간

- "지금 최선"이 나중에 큰 손해로 이어질 수 있는 구조인가?
- 선택이 이후 선택 공간을 크게 바꾸는가?
- 반례를 아주 쉽게 만들 수 있는가?

### 6.2 예시: 거스름돈(특정 동전 체계에서만 정답)

동전이 `500, 100, 50, 10`처럼 특정 체계(정규적 coin system)에서는 그리디가 최적이지만,
임의의 동전 체계에서는 반례가 생길 수 있습니다.

---

## 7. 🚀 실전 문제 풀이 루틴(암기 대신 '생각의 순서')

1. **문제 재정의**: 입력/출력, 제약 조건, 예외(빈 입력/최대값)를 명확히 하기
2. **가장 단순한 해(Brute Force)**: 정답이 나오는 기준점을 먼저 만들기
3. **병목 찾기**: 시간/메모리 병목이 어디인지(Big-O로) 짚기
4. **도구 선택**: 정렬/해시/힙/투포인터/DP/그래프 탐색 중 무엇이 병목을 줄이는지 결정
5. **검증**: 경계값 + 반례(특히 그리디/이진탐색/DP 인덱스)로 테스트

> **마지막 조언:** 알고리즘은 외우는 게 아니라, **문제를 단순화하는 “관점”을 고르는 일**입니다.
