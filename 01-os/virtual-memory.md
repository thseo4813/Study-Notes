# 가상 메모리(Virtual Memory)와 페이지 교체 알고리즘

## 1. 핵심 요약 (Executive Summary)

가상 메모리는 **물리적 메모리(RAM)의 한계를 극복**하기 위한 운영체제의 핵심 기술이다. 각 프로세스에게 독립된 주소 공간을 제공하면서도, 실제로는 제한된 물리 메모리를 효율적으로 공유하고 관리한다.

> **결론:**
> 1. **메모리 추상화:** 프로세스는 자신만의 4GB/16GB 주소 공간을 가짐
> 2. **효율적 관리:** 페이지 교체 알고리즘으로 메모리 활용 극대화
> 3. **안정성 향상:** 메모리 보호와 프로세스 격리 보장
> 4. **성능 최적화:** 지역성(Locality) 원칙을 활용한 캐싱 전략

---

## 2. 가상 메모리의 탄생 배경

### 2.1 물리 메모리의 한계

**1950-60년대 컴퓨터의 문제:**
- **메모리 부족:** 프로그램 크기가 메모리 용량을 초과
- **메모리 단편화:** 프로그램 로드/언로드로 인한 메모리 낭비
- **동시 실행 제한:** 하나의 프로그램만 실행 가능

### 2.2 가상 메모리의 혁신

**1960년대 IBM의 가상 메모리 시스템:**
- **주소 공간 확장:** 물리 메모리보다 큰 주소 공간 제공
- **보호와 격리:** 프로세스 간 메모리 침범 방지
- **효율적 공유:** 동일 코드의 메모리 공유 가능

---

## 3. 가상 메모리의 핵심 원리

### 3.1 주소 변환 (Address Translation)

**가상 주소 → 물리 주소 변환:**
```
가상 주소 (Virtual Address): 0x12345678
     ↓ MMU (Memory Management Unit)
물리 주소 (Physical Address): 0x87654321
```

#### 3.1.1 페이지 테이블 (Page Table)

가상 주소를 물리 주소로 매핑하는 테이블.

```
[페이지 테이블 구조]
┌─────────────┬─────────────┐
│ 가상 페이지 │ 물리 프레임 │
├─────────────┼─────────────┤
│    0x1000   │   0x8000    │
│    0x2000   │   0x9000    │
│    0x3000   │   0xA000    │
└─────────────┴─────────────┘
```

#### 3.1.2 TLB (Translation Lookaside Buffer)

페이지 테이블 조회를 위한 고속 캐시.

**TLB 작동 원리:**
- **히트(Hit):** TLB에서 바로 주소 변환 (몇 ns)
- **미스(Miss):** 페이지 테이블 조회 후 TLB 업데이트 (수십 ns)

**성능 영향:**
- TLB 히트율 98% 이상 유지 필요
- TLB 미스는 전체 메모리 성능 10-20% 저하

### 3.2 페이징(Paging) vs 세그먼테이션(Segmentation)

| 측면 | 페이징 | 세그먼테이션 |
| --- | --- | --- |
| **단위** | 고정 크기 페이지 (4KB) | 가변 크기 세그먼트 |
| **단편화** | 외부 단편화 없음 | 외부 단편화 발생 |
| **복잡도** | 주소 계산 단순 | 메모리 관리 복잡 |
| **공유** | 페이지 단위 공유 | 세그먼트 단위 공유 |

---

## 4. 페이지 교체 알고리즘 (Page Replacement Algorithms)

메모리가 부족할 때 어떤 페이지를 내보낼지 결정하는 알고리즘.

### 4.1 최적 알고리즘 (Optimal Algorithm)

**이론적 최적:** 미래에 가장 늦게 사용될 페이지를 교체

```text
[페이지 참조열: 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2]

메모리 상태 (3프레임):
시간 → | 7 | 0 | 1 | 2 | 0 | 3 | 0 | 4 | 2 | 3 | 0 | 3 | 2 |
프레임1 | 7 | 7 | 7 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
프레임2 |   | 0 | 0 | 0 | 0 | 0 | 0 | 4 | 4 | 4 | 4 | 4 | 4 |
프레임3 |   |   | 1 | 1 | 1 | 3 | 3 | 3 | 3 | 3 | 3 | 3 | 3 |

페이지 폴트: 7회 (최적!)
```

**단점:** 미래를 예측할 수 없어 실제 구현 불가

### 4.2 FIFO (First In, First Out)

가장 오래된 페이지를 교체.

```text
[동일 참조열]

프레임1 | 7 | 7 | 7 | 7 | 0 | 0 | 0 | 0 | 2 | 2 | 2 | 2 | 2 |
프레임2 |   | 0 | 0 | 0 | 0 | 0 | 0 | 4 | 4 | 4 | 4 | 4 | 4 |
프레임3 |   |   | 1 | 1 | 1 | 3 | 3 | 3 | 3 | 3 | 3 | 3 | 3 |

페이지 폴트: 11회
Belady의 모순: 프레임 증가 시 폴트 증가 가능
```

### 4.3 LRU (Least Recently Used)

가장 오래 사용하지 않은 페이지를 교체.

```text
[동일 참조열]

프레임1 | 7 | 7 | 7 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
프레임2 |   | 0 | 0 | 0 | 0 | 0 | 0 | 4 | 4 | 4 | 4 | 4 | 4 |
프레임3 |   |   | 1 | 1 | 1 | 3 | 3 | 3 | 3 | 3 | 3 | 3 | 3 |

페이지 폴트: 9회 (실제 구현 가능)
```

### 4.4 LFU (Least Frequently Used)

사용 빈도가 가장 낮은 페이지를 교체.

**장점:** 장기적 사용 패턴 반영
**단점:** 최근에 자주 사용된 페이지가 오래 유지될 수 있음

### 4.5 Clock Algorithm (시계 알고리즘)

LRU의 근사 구현으로 실제 OS에서 많이 사용.

```text
[Clock 알고리즘 작동]

참조 비트: 1(최근 사용), 0(오래됨)
포인터: 다음 검사할 프레임을 가리킴

시간 1: [1, 0, 1, 0] ← 포인터가 여기서 시작
시간 2: [1, 0, 1, 0] ← 포인터 이동, 0인 프레임 찾음
시간 3: [1, 0, 0, 0] ← 첫 번째 0을 1로 변경
```

---

## 5. 가상 메모리 관리 심층

### 5.1 메모리 할당 전략

#### 5.1.1 요구 페이징 (Demand Paging)

페이지를 필요할 때만 메모리로 로드.

**장점:**
- 빠른 프로그램 시작
- 메모리 절약
- 대용량 프로그램 실행 가능

**단점:**
- 페이지 폴트 발생으로 성능 저하

#### 5.1.2 사전 페이징 (Prepaging)

프로그램 시작 시 필요한 페이지를 미리 로드.

**장점:**
- 초기 페이지 폴트 감소
- 예측 가능한 성능

**단점:**
- 불필요한 메모리 사용 가능

### 5.2 메모리 압축과 스와핑

#### 5.2.1 스와핑 (Swapping)

전체 프로세스를 디스크로 내보내고 불러옴.

```bash
# Linux에서 스왑 영역 설정
sudo fallocate -l 2G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
```

#### 5.2.2 메모리 압축 (Memory Compaction)

사용 중인 메모리를 재배치하여 큰 연속 공간 확보.

### 5.3 메모리 맵 파일 (Memory-Mapped Files)

파일을 메모리에 직접 매핑.

```c
// C 언어 mmap 예시
#include <sys/mman.h>

int fd = open("large_file.dat", O_RDONLY);
char *mapped = mmap(NULL, file_size, PROT_READ, MAP_PRIVATE, fd, 0);

// 이제 배열처럼 접근 가능
char data = mapped[1000];
```

---

## 6. 가상 메모리의 성능 최적화

### 6.1 지역성(Locality) 원칙

**시간 지역성 (Temporal Locality):** 최근 사용한 데이터는 곧 다시 사용될 가능성 높음
**공간 지역성 (Spatial Locality):** 인접 데이터는 함께 사용될 가능성 높음

### 6.2 워킹 셋 (Working Set)

프로세스가 활발히 사용하는 페이지들의 집합.

**워킹 셋 추적:**
- **윈도우 크기:** 최근 n개의 메모리 참조
- **워킹 셋 크기:** 고유 페이지 수

**용도:**
- 메모리 할당량 결정
- 페이지 교체 정책 수립
- 시스템 성능 모니터링

### 6.3 페이지 크기 최적화

**작은 페이지 vs 큰 페이지:**

| 페이지 크기 | 장점 | 단점 |
| --- | --- | --- |
| **작은 페이지 (4KB)** | 메모리 낭비 적음, 정밀한 할당 | 페이지 테이블 크기 증가, TLB 미스 증가 |
| **큰 페이지 (2MB/1GB)** | TLB 효율 향상, 페이지 테이블 축소 | 내부 단편화 증가, 메모리 낭비 |

**현대 트렌드:** 투명 거대 페이지 (Transparent Huge Pages)
- 자동으로 큰 페이지 할당
- 애플리케이션 수정 없이 성능 향상

---

## 7. 가상 메모리 관련 문제와 해결

### 7.1 스레싱 (Thrashing)

페이지 폴트가 과도하게 발생하는 현상.

**원인:**
- 메모리 부족
- 너무 많은 프로세스 동시 실행
- 비효율적인 페이지 교체

**해결책:**
- **워킹 셋 모델:** 충분한 메모리 할당
- **프로세스 일시 중단:** 메모리 확보를 위해 프로세스 중단
- **지역성 개선:** 프로그램 구조 최적화

### 7.2 메모리 단편화

#### 7.2.1 외부 단편화 (External Fragmentation)

할당된 메모리 사이의 빈 공간.

**해결:** 페이징 또는 메모리 압축

#### 7.2.2 내부 단편화 (Internal Fragmentation)

페이지 내의 미사용 공간.

**해결:** 작은 페이지 크기 사용 (단편화 vs 오버헤드 트레이드오프)

### 7.3 메모리 누수 (Memory Leak)

할당된 메모리가 해제되지 않는 현상.

```c
// 메모리 누수 예시
void leaky_function() {
    int *ptr = malloc(sizeof(int) * 100);
    // free(ptr); // 누락됨!
}
```

**발견 도구:**
```bash
# Linux valgrind로 메모리 누수 검사
valgrind --leak-check=full ./program

# Windows에서 CRT 라이브러리로 검사
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
_CrtDumpMemoryLeaks();
```

---

## 8. 현대 운영체제의 가상 메모리

### 8.1 Linux 가상 메모리 관리

**주요 컴포넌트:**
- **Buddy System:** 물리 메모리 할당
- **Slab Allocator:** 커널 객체 할당
- **vmstat:** 메모리 통계 모니터링

```bash
# 메모리 상태 확인
vmstat -s
cat /proc/meminfo

# 페이지 캐시 상태
cat /proc/vmstat | grep page
```

### 8.2 Windows 메모리 관리

**주요 특징:**
- **페이지 파일:** 자동 크기 조정
- **메모리 압축:** Windows 10부터 도입
- **Superfetch:** 사용 패턴 기반 사전 로드

### 8.3 macOS 메모리 관리

**압축 메모리 (Compressed Memory):**
- 메모리 압축으로 스와핑 감소
- 메모리 효율성 향상

---

## 9. 프로그래밍에서의 가상 메모리 활용

### 9.1 메모리 매핑 파일

**장점:**
- 큰 파일 효율적 처리
- 메모리 공유 간단
- 디스크 I/O 최소화

```python
# Python 메모리 매핑
import mmap

with open('large_file.dat', 'r+b') as f:
    # 파일을 메모리에 매핑
    mm = mmap.mmap(f.fileno(), 0)

    # 배열처럼 접근
    data = mm[1000:1100]
    mm.close()
```

### 9.2 공유 메모리

프로세스 간 메모리 공유.

```c
// POSIX 공유 메모리
#include <sys/mman.h>
#include <fcntl.h>

#define SHM_NAME "/my_shared_memory"
#define SHM_SIZE 1024

int shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, 0666);
ftruncate(shm_fd, SHM_SIZE);

void *ptr = mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
```

### 9.3 메모리 풀 (Memory Pool)

미리 메모리를 할당하여 오버헤드 감소.

```cpp
// C++ 메모리 풀 구현
class MemoryPool {
private:
    std::vector<void*> freeList;
    size_t blockSize;

public:
    MemoryPool(size_t blockSize, size_t poolSize) : blockSize(blockSize) {
        for (size_t i = 0; i < poolSize; ++i) {
            freeList.push_back(malloc(blockSize));
        }
    }

    void* allocate() {
        if (freeList.empty()) return nullptr;
        void* ptr = freeList.back();
        freeList.pop_back();
        return ptr;
    }

    void deallocate(void* ptr) {
        freeList.push_back(ptr);
    }
};
```

---

## 10. 성능 모니터링과 튜닝

### 10.1 주요 메트릭

**페이지 폴트율 (Page Fault Rate):**
- **단기:** 0-10% (정상)
- **장기:** 10-50% (주의)
- **심각:** 50% 이상 (스레싱)

**메모리 사용률:**
- **RAM 사용률:** 80% 이상 주의
- **스왑 사용률:** 10% 이상 성능 저하

### 10.2 튜닝 도구

#### Linux
```bash
# 메모리 사용량 모니터링
free -h
vmstat 1

# 프로세스별 메모리 사용
ps aux --sort=-%mem | head

# 캐시 클리어 (주의: 시스템 성능 영향)
echo 3 > /proc/sys/vm/drop_caches
```

#### Windows
```powershell
# 메모리 정보 확인
Get-Counter '\Memory\*'

# 프로세스별 메모리 사용
Get-Process | Sort-Object WS -Descending | Select-Object -First 10
```

### 10.3 최적화 전략

**1. 애플리케이션 레벨:**
- 메모리 풀 사용
- 객체 재사용
- 가비지 컬렉션 최적화

**2. 시스템 레벨:**
- 충분한 RAM 확보
- SSD 사용으로 스왑 속도 향상
- NUMA 아키텍처 활용

---

## 11. 실무 적용 사례

### 11.1 대용량 데이터베이스

**메모리 매핑 인덱스:**
- B-Tree 인덱스를 메모리에 매핑
- 디스크 I/O 최소화
- 검색 성능 10-100배 향상

### 11.2 고성능 컴퓨팅 (HPC)

**메모리 선호도 (NUMA):**
- CPU와 가까운 메모리 우선 사용
- 크로스 소켓 메모리 접근 지연 최소화

### 11.3 컨테이너 환경

**메모리 제한과 OOM Killer:**
```yaml
# Kubernetes 메모리 제한
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: my-app
    resources:
      limits:
        memory: "1Gi"
      requests:
        memory: "512Mi"
```

---

## 12. 미래 전망

### 12.1 지속 메모리 (Persistent Memory)

**Intel Optane과 같은 기술:**
- DRAM과 SSD의 중간 성능
- 비휘발성 메모리
- 가상 메모리 패러다임 변화

### 12.2 메모리 중심 컴퓨팅

**메모리 용량 증가 추세:**
- 2024년: DDR5, 128GB+ 메인스트림
- 2025+: HBM3, 3D 스태킹 기술
- 결과: 가상 메모리 중요성 감소

### 12.3 AI/ML에서의 활용

**메모리 최적화:**
- 메모리 매핑 데이터셋
- GPU 메모리 관리
- 분산 메모리 학습

---

## 13. 결론

가상 메모리는 현대 컴퓨팅의 근간을 이루는 핵심 기술이다. 물리적 메모리의 한계를 극복하면서도, 프로세스 격리와 효율적인 메모리 관리를 동시에 달성한다.

**핵심 교훈:**
1. **지역성 활용:** 시간적/공간적 지역성을 고려한 설계
2. **알고리즘 선택:** 상황에 맞는 페이지 교체 알고리즘 적용
3. **모니터링 중요:** 메모리 사용 패턴 지속적 모니터링
4. **하드웨어 이해:** CPU 캐시와 메모리 계층 구조 파악

**현대 개발자를 위한 조언:**
- 메모리 프로파일러 활용 (Valgrind, VisualVM)
- 메모리 사용 패턴 분석
- 캐시 친화적 코드 작성
- 메모리 제한 환경 고려

---

*"가상 메모리는 컴퓨터 과학에서 가장 성공적인 추상화 중 하나다. 프로그래머에게는 무한 메모리를, 시스템에게는 효율적 관리를 제공한다."*

> 가상 메모리를 깊이 이해하면 더 효율적이고 안정적인 소프트웨어를 만들 수 있다. 메모리는 여전히 가장 느린 하드웨어이므로, 현명한 관리가 성능의 핵심이다.